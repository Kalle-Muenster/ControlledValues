/*///////////////////////////////////////////////////////////*\
||                                                           ||
||     File:      PinJackStruct.hpp                          ||
||     Author:    Autogenerated                              ||
||     Generated: 16.09.2022                                 ||
||                                                           ||
\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
#ifndef _PinJackStruct_hpp_
#define _PinJackStruct_hpp_

BEGIN_STEPFLOW_NAMESPACE

/* PinJack - implements the 'Pin' mechanism (the 'PinFieldController' also provides
// this for providing fix, indexable, enumerable accesspoints to variables/functions
// which are not nessessarly being either pointer or value... these always supporting
// both mechanisms same time. a 'Pin' in the first place is valuetype variable declared
// on a fix position, defined as a class member (so it's not a compositional thing.
// it's compiletime hardcoded as class member variable - not removable or addable to
// any kind of dynamically changable member lists.
// ...but it provides a mechanism which makes possible 'joining' a 'Pin' with another
// 'Pin' which can be declared on other object. joining means: as soon a 'Pin' gets
// assingned a pointer to it, which point to an address of another 'Pin' variable on
// another object, then the pin changes it's type (with that asignment), stops being
// a value type and turns to being a pointer type then - and will point that address
// of the other distant 'Pin' instance then while stil supporting assigning values to
// it, same as it did when it was a value type before.
// the assigner/caller cannot determeine if the Pin where it asigns value to actually
// maybe forwards asignments to some other Pin located on another controller on another
// object mayby. the effect is almost same like circumstances in a uninon are inflicted
// where several member variables at once sharing same memory loction together. (in a
// union, there may be several filds declared and asignable.. but assigning data to
// just one of these fields - makes all union member variables changing their value so.
// same situation comes up as soon two Pins have been joind. At both pins the same value
// will sit. due to both pin same location in memory. so no calls or any kind processing
// is needed then for transporting values between two joined pins - they will have same
// value, ...always.
// like two atoms orbitally bound to each other. both having an owned electron each, but
// indeed it is one same electron. within both of the atoms orbitals at same time at the
// same place. */



template<typename pT>
struct PinJack
{

    union Jack {
        ulong dat;
        pT*   ptr;
        pT    var;
        Jack() { dat = 0; }
    } pin;

    union Trick {
        ulong ptr;
        slong flg;
        Trick() { ptr = 0; }
    } ext;

    PinJack& operator =( pT* assignPointer ) {
        point( assignPointer );
        return *this;
    }

    PinJack& operator =( pT assignValue ) {
        write( assignValue );
        return *this;
    }

    operator pT (void) {
        return read();
    }

    operator pT* (void) {
        return find();
    }

    template< typename U = stepflow::UserModeControl<pT> > U* umode(void) {
        return reinterpret_cast<U*>((void*)(ext.ptr & 0x7FFFFFFFFFFFFFFF));
    }

    bool external( void ) { return ext.flg < 0; }
    bool external( bool set ) {
        ext.ptr = set
     ? (ext.ptr | 0x8000000000000000)
     : (ext.ptr & 0x7FFFFFFFFFFFFFFF);
        return ext.flg < 0;
    }

    PinJack() {}
    PinJack( ulong umode ) {
        ext.ptr = umode;
    }
    PinJack( const PinJack& copy ) {
        pin = copy.pin;
        ext = copy.ext;
    }
    void point( pT* assignPointer ) {
        pin.ptr = assignPointer;
        external( assignPointer );
    }
    pT* find( void ) {
        return ext.flg < 0 ? pin.ptr : &pin.var;
    }

    virtual void write( pT val ) {
        if (ext.flg < 0) *pin.ptr = val;
        else pin.var = val;
    }
    virtual pT read( void ) {
        return ext.flg < 0 ? *pin.ptr : pin.var;
    }
    __declspec( property( get = read, put = write ) ) pT Val;
    __declspec( property( get = find, put = point ) ) pT* Ptr;
};

ENDOF_STEPFLOW_NAMESPACE
#endif
